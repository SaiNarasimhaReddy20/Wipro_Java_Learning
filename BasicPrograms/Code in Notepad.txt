package com.wipro;

import java.util.Scanner;

//Milestone-1 --- Arrays & Strings  ( Syntax and Naming conventions)
//Capstone -- 20 rubrics(front end / BackEnd // Syntaxes , NC , Comments )
//Concrete class
public class HelloWorld {

	//Entry Point of your Java Program
	//static is a keyword which can be called by the compiler without any object 
	//void : this method does not return any value
	// main : the name of methods recognized by the JVM as an entry point
	//String[] args : String is a class and [] means an array so it's an array of strings that can receive command line arguments
	public static void main(String[] args) {
		// is used to print output to the console then followed by a new line character.
		//System is a class , out is a reference variable , println is a method of PrintStream class
		// another reference variable of a system class is in and err
		System.out.println("Hello Java World!");
		
		//To take input
		Scanner sc = new Scanner(System.in);
		
		String var = sc.next();
		
		//To print errors
		System.err.print("Error in your program");
		
    
	}
	
---------------------------------------------------------------------------------------------------------------------------------------------------------------
package com.wipro;



public class PrimitiveandNonPrimitive {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		//Primitive Data Types  ---  Basic Built in types that stores values directly in memory 
		// Here we can single value as well as single type of data will be stored
		
	/*Higher to lower size  then explicit casting is required also called it as
	 * downward casting or Narrowing Casting
	 * 
	 * short s =10;
	 * byte b =(byte)s; // casting is required
	 */
		byte b=10 ;		//1 byte - 8 bits
		short s =20;	//2 bytes - 16 bits
		int  a =20; 	//4 bytes - 32 bits
		long l =4556L;	 // 8 bytes - 64 bits
		float f= 45.50f;	//4 bytes - 32 bits
		double d = 45.78;	// 8 bytes - 64 bits
		char c ='A';		// 2 bytes - 16 bits 
		boolean flag = true ;	//1 bit 
		
	
	
		/*Lower to Higher size  then implicit casting takes place automatically and also called it as
		 * Upward casting or Widening Casting
		 * 
		 * byte s =10;
		 * short b =a; // No casting is required
		 */	
		
// Use of primitive data types is more 
// critical in performance based applications
// like calculations , counters , flags 
		
// Limitations are that they do provide built-in 
// methods (eg char cannot call .toUpperCase())
		
		
	//NON- Primitive Data types -- Complex types that store the references(memory addresses)to an object
	//(variable Size)	 // and somewhere also stores the different type of data and multiple data can be stored
	// String , Array , Class , Interface , Records , Enumeration
	String firstName = "Niti Dwivedi"; 	 // String is immutable
	int[]  arr = {3,4,5};
	//Any noun -- Class is a blueprint or a template which is a non-primitive data type which 
	// declares the different types of data 
	class Employee {String name ;int age; int empId;}
	{
	//To access the class we use object of a class
	Employee e = new Employee();
	System.out.println(e.name);
	}
	//Interface is also a blueprint of all abstract methods to declare it 
	interface Swiggy {void order();}
	
	//Enum is a special class that represents a group  of named constants (unchangeable, predefined value)
	enum Day
	{
		Monday , Tuesday , Wednesday , Thurday , Friday ,Saturday , Sunday
	}
     // To access these values 
	Day today =  Day.Monday;
	
	//It's introduced in Java 16
	// Record - It is a compact, immutable data class that automatically provides getter, toString(),
	//equals(), hashCode(), constructor
	
	 record User(String name ,  int age) {}
	 //How to acces
	  User user = new User("Niti" , 34);
	}
	
		
	

}
----------------------------------------------------------------------------------------------------------------------------------------------------------------

package com.wipro;


//local variable , instance variable,static variable (Method Area), final variables(Varies)

// variables are named one and act as a container for storing data , They must be declared with a type
 class VariablesStructure {
	
	// Non-static or Instance variables -- these are stored in heap
	int id =101;
	String designation="Trainer";
	
	//Stored with object data so it is a part of heap and stored in heap only
	final double price= 45.67; 
	
	//Static variable memory allocation will be once and also the same will be shared by all objects.
	//Method area (Meta Space)  where class definitions , static variables , method info
	static int count=0;
	
	//local variable as inside a method or a block
	// Local variables memory will be stored in stack  -- temporary stored
	public static void main(String[] args)
	{
		
		int a =10;
	}
	
	//Method
	public void Input()
	{
		
		int age =30;
		String name = "Jiya";
		
		// stored in Method Area
		final double cost=56.90; 
		
	}
	
	//Block
	static
	{
		
		
		// final variables cannot be changed 
		//Stored in a constant pool
		final int b =20; //  can't be reassigned and stored in a stack(Local context)
		
		
		
	}
	

}
 
 public class VariablesInJava
 {
	 static int staticCount = 0; // Method Area
	 final double pi =3.14 ; // Heap (final instance variable)
	 String name ; //Heap
	 
	 
	 public void Input1()
	 {
		 
		 int localVar = 300; // stack
		 final int localConst = 200; // stack
		 
		 System.out.println(localVar + " " + localConst);
		 // you can access without an object reference and if you are calling in same class
		// System.out.println(count);
		 System.out.println(staticCount);
	 }
	 
	 public static void main(String[] ar)
	 {
		 // Object is in Heap & reference variables is in stack
		 VariablesInJava vij = new VariablesInJava();
		 System.out.println(vij.pi);
		 vij.Input1();
		 System.out.println(vij.staticCount);
		 System.out.println(VariablesInJava.staticCount);
		 System.out.println(staticCount);
		 
		 VariablesStructure vs = new VariablesStructure();
		 System.out.println(vs.count);
		 
	 }
	 
 }


----------------------------------------------------------------------------------------------------------------------------------------------------------

package com.wipro;

public class StaticNonStatic {
	
	static int studentCount =0;
	String name;
	int age;
	
	StaticNonStatic()
	{
		studentCount++;
	}
	
	void show()
	{
		
		System.out.println(studentCount);
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		
		StaticNonStatic  staticobject = new StaticNonStatic();
		staticobject.show(); //1
		
		StaticNonStatic  staticobject1 = new StaticNonStatic();
		staticobject1.show(); //2
		
		StaticNonStatic  staticobject2 = new StaticNonStatic();
		staticobject2.show(); //3
	}

}


-------------------------------------------------------------------------------------------------------------------------------------------------------------

2nd examples on Variables in Java

package com.wipro;


//local variable , instance variable,static variable (Method Area), final variables(Varies)

// variables are named one and act as a container for storing data , They must be declared with a type
 class VariablesStructure {
	
	// Non-static or Instance variables -- these are stored in heap
	int id =101;
	String designation="Trainer";
	
	//Stored with object data so it is a part of heap and stored in heap only
	final double price= 45.67; 
	
	//Static variable memory allocation will be once and also the same will be shared by all objects.
	//Method area (Meta Space)  where class definitions , static variables , method info
	static int count=10;
	
	int countVar = 10;
	
	

	//local variable as inside a method or a block
	// Local variables memory will be stored in stack  -- temporary stored
//	public static void main(String[] args)
//	{
//		
//		int a =10;
//	}
	
	
	//Method
	public void Input()
	{
		
		
		
		
		int age =30;
		String name = "Jiya";
		
		// stored in Method Area
		final double cost=56.90; 
		
	}
	
	//Block
	static
	{
		
		
		// final variables cannot be changed 
		//Stored in a constant pool
		final int b =20; //  can't be reassigned and stored in a stack(Local context)
		System.out.println("From static block:" + b);
		
		
	}
	

}
 
 public class VariablesInJava
 {
	 static int staticCount = 0; // Method Area
	 final double pi =3.14 ; // Heap (final instance variable)
	 String name ; //Heap
	 
	 
	 public void Input1()
	 {
		 
		 int localVar = 300; // stack
		 final int localConst = 200; // stack
		 
		 System.out.println(localVar + " " + localConst);
		 // you can access without an object reference and if you are calling in same class
		// System.out.println(count);
		 System.out.println(staticCount);
	 }
	 
	 public static void main(String[] ar)
	 {
		 // Object is in Heap & reference variables is in stack
		 VariablesInJava vij = new VariablesInJava();
		 System.out.println(vij.pi);
		 vij.Input1();
		 System.out.println(vij.staticCount);
		
		 VariablesInJava vij2 = new VariablesInJava();
		 System.out.println(vij2.staticCount);

		
		 
		 
		 VariablesStructure vs = new VariablesStructure();
		 System.out.println("Variables Structure Class Object 1");
		 System.out.println(vs.count); 
		 
		 
//		 
	 }
	 
 }



-------------------------------------------------------------------------------------------------------
package com.wipro;

public class StringExample {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		// Creating a string object using a literal
		
		String s = "Niti";  // String Pool in Heap 
		System.out.println(s.hashCode());
		// this gives the actual memory identity where it is stored
		System.out.println(System.identityHashCode(s));
		//  creating a string object using new keyword
		
		String s1 = new String("Nitin"); // Heap  
		
		System.out.println(s1.hashCode());  //if same content as S object has then it will give the same hash
		System.out.println(System.identityHashCode(s1)); // different memory and different value
		
		
		// Whenever the String class overrides
		// the hashCode() method then it is computing on the basis 
		// of the content not the memory location
		
		System.out.println(s==s1); // different memory references
		System.out.println(s.equals(s1)); // it check the content
		
	
		
	}

}





-----------------------------------------------------------------------
package com.wipro;

public class StringExample {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		// Creating a string object using a literal
		
		String s = "Niti";  // String Pool in Heap 
		System.out.println(s.hashCode());
		// this gives the actual memory identity where it is stored
		System.out.println(System.identityHashCode(s));
		//  creating a string object using new keyword
		
		String s1 = new String("Nitin"); // Heap  
		
		System.out.println(s1.hashCode());  //if same content as S object has then it will give the same hash
		System.out.println(System.identityHashCode(s1)); // different memory and different value
		
		
		// Whenever the String class overrides
		// the hashCode() method then it is computing on the basis 
		// of the content not the memory location
		
		System.out.println(s==s1); // different memory references
		System.out.println(s.equals(s1)); // it check the content
		
	
		
		//2nd use case with String concatenation how it works
		
		String svalue1 = "Niti";
		String svalue2 = "Ni" + "ti";   // compiler will treat it as String svalue2 = "Niti" at compile time 
		
		System.out.println(svalue1 == svalue2);  // true  // It is compile time 
		
		String svalue3 = "Ni"; 
		String svalue4 ="ti";
		String oldvalue = "Niti";
		String newvalue = svalue3+svalue4; // It will be evaluated at run time // it will be a new object on heap 
		System.out.println(newvalue);
		System.out.println(oldvalue == newvalue); // false
		System.out.println(oldvalue.equals(newvalue)); // true
		
		
		
		final String svalue5 = "Ni"; 
		final String svalue6 ="ti";
		String oldvalue1 = "Niti";
		String newvalue1 = svalue5+svalue6; //it will be constant at compile time only  -- So compiler will recognize the final values as constant at compile time
		System.out.println(newvalue1);
		System.out.println(oldvalue1 == newvalue1); // true
		System.out.println(oldvalue1.equals(newvalue1)); // true
		
		
		String a = "Niti";
		String b = new String("Niti");
		
		String c = b; 
		
		System.out.println(a==b); //false 
		System.out.println(a==c); // false
		
		
		String a1 = "Niti";
		String b1 = new String("Niti");
		
		String c1 = b1.intern(); // we are manually telling to the compiler to put this string into the pool 
		
		System.out.println(a1==b1); //false 
		System.out.println(a1==c1); // true
		
	}

}

// literal 
// new keyword
// hashCode()
// identityHashCode()
// concatenation at compile time and runtime
// ==  ( comparing the memory reference)
// .equals (comparing the content)
// .intern() (forcing manually to use it as a string pool version)



----------------------------------------------

package com.wipro;

import java.util.Scanner;

public class StringFunctions {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		//Real use cases
		//Email format
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the string");
		String email = sc.next().trim().toLowerCase();
		if(email.contains("@"))
		{
			System.out.println("valid email format");
		}
		else
		{
			System.out.println("Valid email format  is required");
		}
		
		// Password
	
				System.out.println("Enter the password");
				String password = sc.next();
				if(password.equalsIgnoreCase("Admin@123"))
				{
					System.out.println("Password is correct ");
				}
				else 
				{
					System.out.println("Password is incorrect TryAgain! ");
				}
		//when you connecting with the database  (properties url =" " , username , "" , password ="" )
				
		String text = "ssflkjlk djflkj ksdfjlj";
		
		String[] afterSplitting  = text.split(" ");
		
		String value = afterSplitting[0];
		
		// To reverse
		String values = "Java Class";
		String newvalue = new StringBuilder(values).reverse().toString();
		System.out.println("The new value after reversing is :" + newvalue);

		// String Builder and String Buffer are mutable 
		
		StringBuilder sb = new StringBuilder("Niti");
	}

}

/*java.util.regex.Pattern and java.util.regex.Matcher classes are used.
A common regular expression for basic email validation is:
Java

String regex = "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$";
Explanation of the Regex:
^: Asserts the start of the string.
[A-Za-z0-9+_.-]+: Matches one or more occurrences of alphanumeric characters, plus, underscore, dot, or hyphen for the local part (before @).
@: Matches the literal "@" symbol.
[A-Za-z0-9.-]+: Matches one or more occurrences of alphanumeric characters, dot, or hyphen for the domain name.
\\.: Matches a literal dot, escaping it with a backslash.
[A-Za-z]{2,}: Matches the top-level domain (TLD), which must consist of at least two alphabetic characters. 
$: Asserts the end of the string.
Oops, something went wrong.

*/
------------------------------------------------------
package com.wipro;

import java.lang.System;

public class StringBuilderBuffer {
	
	// asynchronous / synchronous StringBuffer - It's synchronized and it's a thread safe
	public static void main(String[] args) {
		
	//	String cname = "Wipro";
	//	cname = cname + "Ltd"; // create  a new object ,, the original wipro 
		
		long start ,end;
		start = System.currentTimeMillis();
		String s = "";
		
		for(int i=0 ; i<500 ; i++)
		{
			
			s+="Some";
			System.out.println(System.identityHashCode(s));
		}
		end = System.currentTimeMillis();
		System.out.println("Total time taken using String " + (end-start));
		
		//String builder is mutable and fast --- It's not a thread safe
		//Efficient in appending to the same location and no new object will be created  
		start = System.currentTimeMillis();
		StringBuilder sb = new StringBuilder();
		for(int i=0 ; i<500 ; i++)
		{
			
			sb.append("Some");
			System.out.println(System.identityHashCode(sb));
		}
		end = System.currentTimeMillis();
		System.out.println("Total time taken using String Builder " + (end-start));
		
		
		//String Buffer is mutable but slow because of synchronization
		start = System.currentTimeMillis();
		StringBuffer sbuffer = new StringBuffer();
		for(int i=0 ; i<500 ; i++)
		{
			
			sbuffer.append("Some");
			System.out.println(System.identityHashCode(sbuffer));
		}
		end = System.currentTimeMillis();
		System.out.println("Total time taken using String Buffer " + (end-start));
		
		
		
		
	}
	

}
-----------------------------------------------------------

















































































___________________________________________________________________________________________________________________________
package Activity;
import java.util.Scanner;

public class EmployeeManagement {

	public static void main(String[] args) 
	{
		//Creating array for Employee
		Scanner sc= new Scanner(System.in);
		
		while(true)
		{		
			System.out.println(" 1: add");
			System.out.println(" 2: view");
			System.out.println(" 3: update");
			System.out.println(" 4: search");
			System.out.println(" 5: delete");
			System.out.println(" 6: exit");
			System.out.println("Enter Your Choice");
			int choice=sc.nextInt();
			switch(choice)
			{
				case 1:
					Employee.Add();
					break;
				case 2:
					Employee.View();
					break;
				case 3:
					Employee.Update();
					break;
				case 4:
					Employee.Search();
					break;
				case 5:
					Employee.Delete();
					break;
				case 6:
					Employee.Exit();
					break;
				default:
					System.out.println("Invalid Choice");
			}
			
		}
		
	}

}
---------------------------------------------------------------------------------------------------------------------
/*
Create an Employee class with the following fields: id, name, position, and salary. 
Then, create an array of Employee objects and develop a menu-driven program that allows the user to:
	Add a new employee
	View all employees
	Search for employees by name (using .contains() and .toLowerCase() for case-insensitive matching)
	Update employee details by ID
	Delete an employee by ID
	Exit the program

Also, use relevant String operations such as .equalsIgnoreCase(), .contains(), .toLowerCase(), and .trim() 
for accurate and clean input handling.
*/




package Activity;
import java.util.Scanner;
import java.lang.String;

public class Employee 
{
	int id;
	String name;
	String position;
	double salary;
	
	static int count=0;
	static int empSize=1;
	static Employee[] emp= new Employee[empSize];
	
	//Created a constructor for Employee Class
	Employee(int id,String name,String position,double salary)
	{
		this.id=id;
		this.name=name;
		this.position=position;
		this.salary=salary;
	}
	
	@Override
	public String toString() {
		return "Employee [ID=" + id + ", Name=" + name + ", Position=" + position + ", Salary=" + salary + "]";
	}

	//Function to display the Employee Details
	public static void Add()
	{		
		Scanner sc= new Scanner(System.in);
		System.out.println("Enter your ID: ");
		int id=sc.nextInt();
		System.out.println("Enter your Name: ");
		String name=sc.next();
		System.out.println("Enter your Position: ");
		String position=sc.next();
		System.out.println("Enter your Salary: ");
		double salary=sc.nextDouble();
		System.out.println("Details added");
		emp[count++] = new Employee(id,name,position,salary);
		//System.out.println(emp[0]);
	}
	
	
	
	public static void View()
	{		
		for(int i=0;i<empSize;i++)
		{
			System.out.println("ID : "+emp[i].id);
			System.out.println("Name : "+emp[i].name);
			System.out.println("Position : "+emp[i].position);
			System.out.println("Salary : "+emp[i].salary);
			
		}
	}
	
	public static void Update()
	{
		Scanner sc= new Scanner(System.in);
		System.out.println("Enter Employee ID to update");
		int id=sc.nextInt();
		for(int i=0;i<empSize;i++)
		{
			if (emp[i].id==id)
			{
				System.out.println("Enter New Name: ");
				emp[i].name=sc.next();
				System.out.println("Enter your Position: ");
				emp[i].position=sc.next();
				System.out.println("Enter your Salary: ");
				emp[i].salary=sc.nextDouble();
				System.out.println("Details Updated");
			}
		}
	}
	
	public static void Search()
	{
	
		Scanner sc= new Scanner(System.in);
		System.out.println("Enter name to search");
		String nameSearch=sc.next().toLowerCase();
		for(int i=0;i<empSize;i++)
		{
			if(emp[i].name.contains(nameSearch))
			{
				emp[i].View();
			}
		}
	}
	
	public static void Delete()
	{
		
		Scanner sc= new Scanner(System.in);
		System.out.println("Enter the Employee ID which need to be deleted: ");
		int delID=sc.nextInt();
		for(int i=0;i<empSize;i++)
		{
			if(emp[i].id==delID)
			{
				emp[i]=null;
			}
			else {
				System.out.println("Employee ID not found");
			}
		}
	}
	public static void Exit()
	{
		System.exit(0);
	}

}
------------------------------------------------------------------------------