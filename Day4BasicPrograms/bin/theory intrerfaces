Encapsulation (data hiding by wrapping the data members & member functions) & Abstraction (code/ Business Logic -  implementation hiding) --- Hiding 


Abstraction -- Abstract & Interface

Hiding the implementation and showing the necessary/relevant information -- What is an object 

Abstract classes are not 100% abstraction  --- we are implementing using abstract keyword : In abstract class we have both abstract methods as well as 
non abstract method --  where implementation/definition of abstract methods will be given by child class while overriding the abstract methods which is mandatory to override the abstract methods
and overriding is not mandatory for non abstract methods
//Amazon                                                                    Zara (.net/java (api for paymentProcessing))
abstract class Payment{
            
           private int years = 2;
           
           public int getYears()
           {
           return years;
           }
                                                                               class ProductPayment extends Payment
//abstract method  --  (methods declared without an implementation)              
abstract void paymentProcessing() ;                                            {  // Zara has to give the implementation or definition of paymentProcessing method because it is abstract   }

   // api -- call  (hidden implementation)

//non -abstract method
void discount()
{
// we can give the definition
 
}

}


interface --- (100% abstraction) --we are implementing using interface keyword  where all methods are by default abstract  (but before java 1.8) because after 1.8 onvwards we do have static or default methods for extension( as in functional interface)-- 

It's an agreement/contract where the implementation of all methods of an interface will be given by a child class and by default the variables in an interface are final
Interface is used to achieve 100% abstraction  
Swiggy																		PizzaHut
interface Process                                                     class Deliver implements Process
{                                                                        {// override all the three methods that are mandatory and give the definition}

// by default it is abstract
 void paymentProcessing() ;

 
 void productListing();

 void productPrice();


}


interface CrudOperations             class AdminUser implements CrudOperations
{										{

void add();								void add(){}
															
void delete();							void delete() {}
void update();							void update(){}
void view();								void view(){}
}										}						

class Hr implements CrudOperations
{										{

							void add(){}														
							void delete() {}
							void update(){}
							void view(){}
}										}







--------------------------------------------
package com.example.oops;


//In interface generally we are not writing any logic part or implementation so that's why 
// it's an public so that we can access methods 
public interface Discountable {
	
	 double calculateDiscount();  // by default it's an abstract method

}


------------------------------------------------------------

package com.example.oops;

public class SeasonalProduct implements Discountable{
	
	private String name;
	private double price;
	
	public SeasonalProduct(String name, double price) {
		super();
		this.name = name;
		this.price = price;
	}
	
	@Override
	public double calculateDiscount() {
		// TODO Auto-generated method stub
		return price*0.10;
	}

	
	public void show()
	{
		
	//	System.out.println("Seasonal Discount : "+name+price+calculateDiscount());
		
   System.out.printf("Seasonal : %s | Price: Rs. %.2f | Discount: Rs. %.2f%n" ,name,price,calculateDiscount());
	}




	
	
	

}

---------------------------------------------------------------------


package com.example.oops;

public class ClearanceProduct implements Discountable{
	
	private String name;
	private double price;
	
	public ClearanceProduct(String name, double price) {
		super();
		this.name = name;
		this.price = price;
	}
	@Override
	public double calculateDiscount() {
		// TODO Auto-generated method stub
		return price*0.50;
	}
	
	public void show()
	{
		
		System.out.printf("Clearance : %s | Price: Rs. %.2f | Discount: Rs. %.2f%n" ,name,price,calculateDiscount());  
	}
	
	
}


------------------------------------------------------------------------------------


package com.example.oops;

// Main Program of Interface creating an array of Discountable Interface and storing the object of 
// two classes (SeasonalProduct.java and ClearanceProduct.java) implementing the abstract method of an Interface
public class InterfaceDiscountAppExample {

	public static void main(String[] args) {
		
		// As we know that we cannot create an object of Interface ,
		//so here we are creating an array for allocating only a space of n for holding the references to an objects of those classes who all are implementing the Discountable interface 
		
		Discountable[] discounts = new Discountable[2];
		
		// for eg: String[] s = new String[2];
		
		      
		
		discounts[0] = new SeasonalProduct("Laptop" , 3000);
		discounts[1] = new ClearanceProduct("Old SmartPhone" , 5000);
		
		System.out.println("Discount Summary Report");
		
		for(Discountable d : discounts)
		{
			
			if(d instanceof SeasonalProduct sp) sp.show();
			else if(d instanceof ClearanceProduct cp) cp.show();
			
		}

	}

}
-------------------------------------------------------------------------------
Inheritance : where a child class inherits properties and methods from parent(super ) class using the extends keyword
              and it enables code reuse , hierarchical structure and also support polymorhism.
              
Types of Inheritance:
a) Single INheritance : one child(sub or derived class) and one parent(super ,base class)

for eg :  class Father{}     ,   class Child extends Father {}
b) Multilevel Inheritance : one child class extends one base class and then the another child class extends the child class

for eg :  class Father{}   , class Child extends Father{} ,   class GrandChild extends Child{}

c) Multiple Inheritance ( which is implemented via Interface) --  one class can implements two interfaces

for eg:   interface Operations{} , interface Execution{}   ,  class MainProgram implements Operations, Execution

* Second ex. is not possible :  class Father{}   , class Child extends Father{} ,   class GrandChild extends Father , Child 
* Third  ex. is possible : class Father{}   , interface Operations{} ,   class Child extends Father implements Operations {}
* Fourth ex. is not possible : class Father{}   , interface Operations{} ,   class Child implements Operations extends Father {}
* Fifth  ex. is possible:   interface Operations{} , interface Execution extends Operations{}   

d) Hierarchical Inheritance  : --  When multiple subclasses extending one same Parent 

for eg :  class GrandFather{}   , class Father extends GrandFather{} ,   class Child extends GrandFather{}

e) Hybrid Inheritance  --- Mix of types  eg : Hierarchical + interface based multiple inheritance

Super keyword is used in inheritance generally 
1. Super keyword is used to access the parent class fields or methods when overridden in child class  (super.field or super.method() you are calling in child  class of base class)
2. Super keyword  must be the first statement in the subclass constructor if used.
3. A subclass inherits only non-private or protected members of a base class.
4. super can't be used in static context.

---------------------------------------------------------------------------------------